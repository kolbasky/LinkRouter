package launcher

import (
	"fmt"
	"linkrouter/internal/config"
	"linkrouter/internal/dialogs"
	"linkrouter/internal/registry"
	"linkrouter/internal/utils"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"syscall"
)

func HandleNoArgs() {
	cfg, err := config.LoadConfig()
	if err != nil {
		dialogs.ShowError("Failed to load config:\n" + err.Error())
		os.Exit(1)
	}

	if cfg.Global.DefaultBrowserPath != "" {
		argsTemplate := cfg.Global.DefaultBrowserArgs
		if !strings.Contains(argsTemplate, "{URL}") {
			argsTemplate += " {URL}"
		}
		launchApp(cfg.Global.DefaultBrowserPath, argsTemplate, "")
	} else {
		dialogs.ShowError("DefaultBrowserPath in linkrouter.json is empty!")
	}
	os.Exit(0)
}

func Help() {
	program := "explorer.exe"
	args := "https://github.com/kolbasky/LinkRouter/blob/main/README.md#linkrouter"
	fullCmdLine := strconv.Quote(program) + " " + strconv.Quote(args)
	cmd_help := exec.Command(program)
	cmd_help.SysProcAttr = &syscall.SysProcAttr{
		CmdLine: fullCmdLine,
	}
	cmd_help.Start()
	os.Exit(0)
	// helpText := `LinkRouter â€“ simple router for handlinkg links based on custom regex rules.

	// USAGE:
	//   linkrouter.exe [URL]           Handle a link
	//   linkrouter.exe --register      Register as default handler for global.supportedProtocols
	//   linkrouter.exe --unregister    Remove registration
	//   linkrouter.exe                 Open default browser

	// 1. Run linkrouter.exe --register
	// 2. Choose as default app for desired link types in windows settings
	// 3. Add your rules to linkrouter.json config

	// CONFIG:
	//   Config is autogenerated next to executable and is named linkrouter.json
	//   Move to %LOCALAPPDATA%\LinkRouter\linkrouter.json or %LOCALAPPDATA%\linkrouter.json if you wish or leave it next to executable

	// EXAMPLE RULES:
	//     {
	//         "regex": "https://store.steampowered.com.*",
	//         "program": "C:\\Windows\\explorer.exe",
	//         "arguments": "steam://openurl/{URL}"
	//     },
	//     {
	//       "regex": "mailto:(.*@(company1|company2).*)",
	//       "program": "C:\\Program Files\\Microsoft Office\\root\\Office16\\OUTLOOK.EXE",
	//       "arguments": "/c ipm.note /profile \"work\" /m $1"
	//     }

	// More info on: https://github.com/kolbasky/LinkRouter`

	// fmt.Fprint(os.Stdout, helpText)
}

func IsCorrectURL(s string) bool {
	return len(strings.TrimSpace(s)) > 1
}

func HandleURL(url string) {
	cfg, err := config.LoadConfig()
	if err != nil {
		dialogs.ShowError("Config error:\n" + err.Error())
		return
	}

	if rule, matches := cfg.MatchRule(url); rule != nil {
		expandedArgs := expandPlaceholders(rule.Arguments, matches)
		err := launchApp(rule.Program, expandedArgs, url)
		if err == nil {
			return
		} else {
			dialogs.ShowError(
				fmt.Sprintf(
					"Failed to launch app %s:\n%s",
					rule.Program,
					err,
				),
			)
		}
	}

	if cfg.Global.DefaultBrowserPath != "" {
		argsTemplate := cfg.Global.DefaultBrowserArgs
		if argsTemplate == "" {
			argsTemplate = "{URL}"
		}
		err := launchApp(cfg.Global.DefaultBrowserPath, argsTemplate, url)
		if err == nil {
			return
		} else {
			dialogs.ShowError(
				fmt.Sprintf(
					"Failed to launch fallback browser:\n%s\nProgram: %s",
					err,
					cfg.Global.DefaultBrowserPath,
				),
			)
		}
	} else {
		dialogs.ShowError("No rule matched and no default browser configured.")
	}
}

// in GO %VARS% are not expanded. so convert then to unix-style
func expandPath(path string) string {
	re := regexp.MustCompile(`%([_a-zA-Z][_a-zA-Z0-9\-]*)%`)
	converted := re.ReplaceAllString(path, `$${$1}`)
	ready_path := os.ExpandEnv(converted)
	return ready_path
}

func containsSupportedProtocol(argsLine string) bool {
	for _, proto := range config.SupportedProtocols {
		cleanProto := registry.ParseProtocol(proto)
		if cleanProto == "" {
			continue
		}
		pattern := `(^|[ \t])` + regexp.QuoteMeta(cleanProto) + `:`
		if matched, _ := regexp.MatchString(pattern, argsLine); matched {
			return true
		}
	}
	return false
}

func isExplorer(path string) bool {
	return strings.EqualFold(filepath.Base(path), "explorer.exe")
}

func launchApp(programPath, argsTemplate, url string) error {
	if programPath == "" {
		return fmt.Errorf("program path is empty")
	}
	program := expandPath(programPath)

	if utils.IsLinkRouter(program) {
		return fmt.Errorf("recursion prevented. " +
			"program specified in rule is linkrouter itself. " +
			"skipping rule")
	}

	quotedProgram := strconv.Quote(program)

	var argsLine string
	if argsTemplate == "" {
		argsLine = ""
	} else {
		argsLine = strings.ReplaceAll(argsTemplate, "{URL}", url)
	}
	if isExplorer(program) && containsSupportedProtocol(argsLine) {
		return fmt.Errorf("recursion prevented. link is passed to explorer.exe and LinkRouter is default for this type of links")
	}
	var fullCmdLine string
	if argsLine == "" {
		fullCmdLine = quotedProgram
	} else {
		fullCmdLine = quotedProgram + " " + argsLine
	}

	cmd := exec.Command(program)
	cmd.Path = program
	cmd.SysProcAttr = &syscall.SysProcAttr{
		CmdLine: fullCmdLine,
	}
	return cmd.Start()
}

func expandPlaceholders(template string, matches []string) string {
	result := template
	for i, match := range matches {
		placeholder := "$" + strconv.Itoa(i)
		result = strings.ReplaceAll(result, placeholder, match)
	}
	return result
}
