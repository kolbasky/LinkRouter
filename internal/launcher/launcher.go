package launcher

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"linkrouter/internal/config"
	"linkrouter/internal/dialogs"
	"linkrouter/internal/logger"
	"linkrouter/internal/registry"
	"linkrouter/internal/utils"
	urlpkg "net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"syscall"
)

func HandleStdIn() {
	config.LoadConfig()
	var length uint32
	if err := binary.Read(os.Stdin, binary.LittleEndian, &length); err != nil {
		logger.Log("Error reading length from stdin:" + err.Error())
		os.Exit(1)
	}

	// Safety: limit message size
	if length > 1024*1024 { // 1 MB
		logger.Log("Error: Message exceeds 1MB")
		dialogs.ShowError("Message exceeds 1MB")
		os.Exit(1)
	}

	// Read JSON payload
	msg := make([]byte, length)
	if _, err := io.ReadFull(os.Stdin, msg); err != nil {
		logger.Log("Error: couldn't read JSON payload:" + err.Error())
		dialogs.ShowError("Couldn't read JSON payload")
		os.Exit(1)
	}

	// Parse JSON
	var req struct {
		URL    string `json:"url"`
		Action string `json:"action"`
	}
	if err := json.Unmarshal(msg, &req); err != nil {
		logger.Log("Error: unable to unmarshal message:" + err.Error())
		os.Exit(1)
	}

	// Prepare default response (in case of URL or unknown action)
	var resp map[string]interface{}

	switch req.Action {
	case "ping":
		exePath, _ := os.Executable()
		resp = map[string]interface{}{
			"status":  "ok",
			"exePath": exePath,
		}

	case "shouldHandle":
		// Check if ANY rule matches — don't launch anything
		handled := shouldHandleURL(req.URL)
		resp = map[string]interface{}{
			"handled": handled,
		}

	default:
		HandleURL(req.URL)
		resp = map[string]interface{}{
			"status": "processed",
		}
	}

	// Send response (always LittleEndian on Windows)
	respBytes, err := json.Marshal(resp)
	if err != nil {
		logger.Log("Error marshaling response:" + err.Error())
		os.Exit(1)
	}

	if err := binary.Write(os.Stdout, binary.LittleEndian, uint32(len(respBytes))); err != nil {
		logger.Log("Error writing response length:" + err.Error())
		os.Exit(1)
	}
	if _, err := os.Stdout.Write(respBytes); err != nil {
		logger.Log("Error writing response:" + err.Error())
		os.Exit(1)
	}
	os.Stdout.Sync()
}

func shouldHandleURL(rawURL string) bool {
	cfg, _ := config.LoadConfig()
	for _, rule := range cfg.Rules {
		re, err := regexp.Compile(rule.Regex)
		if err != nil {
			continue
		}
		if re.MatchString(rawURL) {
			HandleURL(rawURL)
			return true
		}
	}
	return false
}

func HandleNoArgs() {
	if !registry.IsRegistered() {
		result := dialogs.ShowMessageBox(
			"LinkRouter Setup",
			"Would you like to register LinkRouter in your system?",
			0x00000024,
		)
		if result == 6 {
			registry.RegisterApp()
		}
	} else {
		EditConfig()
		// cfg, err := config.LoadConfig()
		// if err != nil {
		// 	dialogs.ShowError("failed to load config:\n" + err.Error())
		// 	os.Exit(1)
		// }

		// url := ""
		// logger.Log("Handling URL: " + url)
		// if cfg.Global.FallbackBrowserPath != "" {
		// 	argsTemplate := cfg.Global.FallbackBrowserArgs
		// 	if !strings.Contains(argsTemplate, "{URL}") {
		// 		argsTemplate += " {URL}"
		// 	}
		// 	launchApp(cfg.Global.FallbackBrowserPath, argsTemplate, url)
		// } else {
		// 	logger.Log("Error: fallbackBrowserPath in linkrouter.json is empty")
		// 	dialogs.ShowError("fallbackBrowserPath in linkrouter.json is empty")
		// }
	}
	os.Exit(0)
}

func EditConfig() {
	cfg, _ := config.LoadConfig()
	editor := cfg.Global.DefaultConfigEditor

	if editor == "" {
		for _, e := range []string{
			"code.exe",
			"subl.exe",
			"atom.exe",
			"webstorm.exe",
			"phpstorm.exe",
			"pycharm.exe",
			"idea64.exe",
			"notepad++.exe",
			"notepad2.exe",
			"notepad3.exe",
			"notepad.exe",
		} {
			if path, err := exec.LookPath(e); err == nil {
				editor = path
				break
			}
		}
		if editor == "" {
			editor = "notepad.exe"
		}
	}

	configPath := config.GetConfigPath()
	err := exec.Command(editor, configPath).Start()
	if err != nil {
		dialogs.ShowError("Failed to find any known text editor in PATH.\n" +
			"Your config is at " + configPath + "\n" +
			"Set global.defaultConfigEditor manually.")
	}
	os.Exit(0)
}

func Help() {
	program := "${SYSTEMROOT}\\explorer.exe"
	args := "https://github.com/kolbasky/LinkRouter/blob/main/README.md#-linkrouter"
	fullCmdLine := strconv.Quote(program) + " " + strconv.Quote(args)
	cmd_help := exec.Command(os.ExpandEnv(program))
	cmd_help.SysProcAttr = &syscall.SysProcAttr{
		CmdLine: fullCmdLine,
	}
	err := cmd_help.Start()
	if err != nil {
		// basically should never get here
		helpText := `LinkRouter – regex-based router for handlinkg links.

USAGE:
 linkrouter.exe [URL]	Handle a link
 linkrouter.exe --register	Register in system
 linkrouter.exe --unregister	Remove registration
 linkrouter.exe		Open default browser

CONFIG:
 Config is autogenerated next to executable and is named linkrouter.json

EXAMPLE RULES:
 {
  "regex": "https://store.steampowered.com.*",
  "program": "C:\\Windows\\explorer.exe",
  "arguments": "steam://openurl/{URL}"
 },
 {
  "regex": "mailto:(.*@(company1|company2).*)",
  "program": "C:\\Program Files\\Microsoft Office\\root\\Office16\\OUTLOOK.EXE",
  "arguments": "/c ipm.note /profile \"work\" /m $1"
 }

More info on: https://github.com/kolbasky/LinkRouter`

		dialogs.ShowMessageBox("LinkRouter Help", helpText, 0x00000040)
	}
	os.Exit(0)
}

func IsCorrectURL(s string) bool {
	return len(strings.TrimSpace(s)) > 1
}

func HandleURL(url string) {
	url = strings.TrimSpace(url)
	cfg, err := config.LoadConfig()
	if err != nil {
		dialogs.ShowError("config error:\n" + err.Error())
		return
	}

	logger.Log(fmt.Sprintf("Handling URL: %s", url))
	if strings.HasPrefix(strings.ToLower(url), "linkrouter-ext://") {
		url = strings.TrimPrefix(url, "linkrouter-ext://")
		logger.Log(fmt.Sprintf("Trimmed URL: %s", url))
	}

	if decoded, err := urlpkg.QueryUnescape(url); err == nil {
		url = decoded
	}

	if rule, matches, ruleIndex := cfg.MatchRule(url); rule != nil {
		logger.Log(fmt.Sprintf("Matched rule #%d: regex=%q", ruleIndex, rule.Regex))
		logger.Log(fmt.Sprintf("Captured groups: %s", logger.FormatCaptureGroups(matches)))

		expandedArgs := expandPlaceholders(rule.Arguments, matches)
		err := launchApp(rule.Program, expandedArgs, url)
		if err == nil {
			return
		} else {
			dialogs.ShowError(fmt.Sprintf(
				"failed to launch app\n%s:\n%s",
				rule.Program,
				err,
			))
		}
	}

	if cfg.Global.FallbackBrowserPath != "" {
		argsTemplate := cfg.Global.FallbackBrowserArgs
		if argsTemplate == "" {
			logger.Log("Arguments are empty appending {URL}")
			argsTemplate = "{URL}"
		}
		err := launchApp(cfg.Global.FallbackBrowserPath, argsTemplate, url)
		if err == nil {
			return
		} else {
			logger.Log(fmt.Sprintf("Error: failed to launch fallback browser. %s", err))
			dialogs.ShowError(fmt.Sprintf(
				"failed to launch fallback browser:\n%s:\n%s",
				cfg.Global.FallbackBrowserPath,
				err))
		}
	} else {
		errorText := "Error: no rule matched and no default browser configured"
		logger.Log(errorText)
		dialogs.ShowError(errorText)
	}
}

// in GO %VARS% are not expanded. so convert then to unix-style
func expandPath(path string) string {
	re := regexp.MustCompile(`%([_a-zA-Z][_a-zA-Z0-9\-]*)%`)
	converted := re.ReplaceAllString(path, `$${$1}`)
	ready_path := os.ExpandEnv(converted)
	return ready_path
}

func containsSupportedProtocol(argsLine string) bool {
	for _, proto := range config.SupportedProtocols {
		cleanProto := registry.ParseProtocol(proto)
		if cleanProto == "" {
			logger.Log("Got empty protocol from SupportedProtocols. Skipping")
			continue
		}
		pattern := `(^|[ \t])` + regexp.QuoteMeta(cleanProto) + `:`
		if matched, _ := regexp.MatchString(pattern, argsLine); matched {
			return true
		}
	}
	return false
}

func isExplorer(path string) bool {
	return strings.EqualFold(filepath.Base(path), "explorer.exe")
}

func launchApp(programPath, argsTemplate, url string) error {
	if programPath == "" {
		logger.Log("Error: program path is empty")
		return fmt.Errorf("program path is empty")
	}
	program, _ := utils.LookupInPATH(expandPath(programPath))

	if utils.IsLinkRouter(program) {
		logger.Log(fmt.Sprintf(
			"Recursion: program %q specified in rule is linkrouter itself. skipping rule.",
			program))
		return fmt.Errorf("recursion prevented.\n" +
			"program specified in rule is linkrouter itself.\n" +
			"skipping rule")
	}

	quotedProgram := strconv.Quote(program)

	var argsLine string
	if argsTemplate == "" {
		argsLine = ""
	} else {
		argsLine = strings.ReplaceAll(argsTemplate, "{URL}", url)
		logger.Log(fmt.Sprintf("Expanded arguments: %s", argsLine))
	}
	if isExplorer(program) && containsSupportedProtocol(argsLine) {
		logger.Log("Recursion: URL is passed to explorer.exe and LinkRouter is set as default for this type of links")
		return fmt.Errorf("recursion prevented.\n" +
			"link is passed to explorer.exe and LinkRouter is set as default for this type of links")
	}
	if isExplorer(program) {
		argsLine = strconv.Quote(argsLine)
	}
	var fullCmdLine string
	if argsLine == "" {
		fullCmdLine = quotedProgram
	} else {
		fullCmdLine = quotedProgram + " " + argsLine
	}

	logger.Log(fmt.Sprintf("Launching: %s", fullCmdLine))

	cmd := exec.Command(program)
	cmd.Path = program
	cmd.SysProcAttr = &syscall.SysProcAttr{
		CmdLine: fullCmdLine,
	}
	return cmd.Start()
}

func expandPlaceholders(template string, matches []string) string {
	result := template
	for i, match := range matches {
		placeholder := "$" + strconv.Itoa(i)
		result = strings.ReplaceAll(result, placeholder, match)
	}
	return result
}
